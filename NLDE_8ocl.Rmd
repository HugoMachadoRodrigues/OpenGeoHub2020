---
title: "NLDE crossvalidation hourly 9"
output:
  html_document:
    df_print: paged
---
 
```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8, fig.path=paste0('hourly_8',"/"),
                      echo=F, warning=FALSE, message=FALSE, dev = "pdf", include = T)
```
 
Required packages
```{r, include=F}
ipak <- function(pkg){
 
   new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
   if (length(new.pkg)) 
    install.packages(new.pkg, dependencies = TRUE , repos='http://cran.muenster.r-project.org')
  sapply(pkg, require, character.only = TRUE)
}
packages <- c( "devtools", "dplyr","data.table" , "ggplot2" , "RColorBrewer", "raster", "rasterVis", "rgdal","Matrix","xgboost",  "glmnet", "ranger", "randomForest"  
,"tidyverse" )
ipak(packages)
#install_github("mengluchu/APMtools") 
 
library(APMtools)
```

```{r}
y_var = "X8_mean_value"
whichhour= 8
# choose "value_mean for the mean of all hours, for different hours: X9_mean_value, X10_mean_value 
sr =  stack("~/Documents/GitHub/nijmegen/predictorsmay20")  
```
 
```{r}
prestring =  "road|pop|temp|wind|RSp|OMI|eleva|indu|trop|" 
varstring = paste0(prestring,y_var)
```
 


```{r}
predictors = read.csv ("~/Documents/GitHub/nijmegen/metendet_data2020.csv",stringsAsFactors = F)
predictors <- as.data.frame(sapply(predictors, as.numeric))

# no2 measurements 
value  = read.csv("~/Documents/Github/nijmegen/DENLjuly.csv", sep = ";")
value_mean = value%>%dplyr::select(X10_mean_value,X11_mean_value,X7_mean_value,X8_mean_value,X9_mean_value)%>%apply(1,mean)
value$value_mean = value_mean

#assign id and merge
value$id = 1:nrow(value)
merged0 = merge(value, predictors, by = "id")
#check 
all.equal(merged0$lon.x,merged0$lon.y)
merged0%>%nrow()
 
# only predictors, and coordinates  
mpredictors = merged0[, c(3,4,28:112)]
# mean over all hours 
 

merged = data.frame(cbind(merged0%>%dplyr::select(y_var),  predictors))%>%na.omit()%>%unique()
# merge road types to form a new road type
merged   = merge_roads(merged ,c(3,4,5), keep = F)
# merged = mergedsp %>% dplyr::select(-lon,-lat.x)
names(merged)
```
  
  
10 percent for testing, wont be touched
```{r, eval=F}

set.seed(2)
smp_size = floor(0.9 * nrow(NLDE))
NLDE_nonsp = NLDE%>%select(-lon,-lat.x)
train_indsp = sample(seq_len(nrow(NLDE_nonsp)), size = smp_size)
test_indsp = seq_len(nrow(NLDE_nonsp))[-train_indsp]

merged = NLDE_nonsp[train_indsp,] 
 
test_inde = NLDE_nonsp[-train_indsp,] 
 
#names(merged)               
#a = lm(value_mean~., data =merged)
#summary(a)
     
```

Variable importance: 20-times bootstrapping
```{r, eval=T}


Impor_val =  function(n,df, method , y_var  ) {

  set.seed(n)
  smp_size <- floor(0.8 * nrow(df))

training<- sample(seq_len(nrow(df)), size = smp_size)
test = seq_len(nrow(df))[-training] 
 
 
methodID = switch(method,  "xboost"=1,"rf" =2, "gb"=3) 

df = switch(methodID,  
            xgboost_imp (variabledf= df, y_varname= y_var, max_depth =3, gamma=1, eta =0.05, nthread = 4, nrounds = 636, training=training, test=test, grepstring =varstring ),  
            rf_imp(df, y_varname= y_var, training=training, test=test, grepstring =varstring,mtry = 24, numtrees = 1000),
            Brt_imp (df, opti = F,   ntree= 2000, y_varname= y_var, training=training, test=test,  grepstring =varstring)

) 
return(df)
}
 
 Vxb = data.frame(lapply(1:20, Impor_val, df= merged, "xboost" , y_var =y_var))
 Vrf =  data.frame(lapply(1:20, Impor_val, df = merged, "rf" , y_var = y_var)) 

mimpVrf = apply(Vrf, 1, median)
mimpxb = apply(Vxb, 1, median)
 
 
xb = names(mimpxb[order(mimpxb,decreasing = T)]  )[1:20]
rf = names(mimpVrf[order(mimpVrf,decreasing = T)] ) [1:20]
vimp=cbind(rank = 1:20, xgboost = xb, randomforest = rf)
#install.packages("stargazer")
library(stargazer)
stargazer(vimp)
```

Crossvalidation: 20-times bootstrapping

```{r, eval=T}
#V2= c("P_LM_NO_OMI_day","P_LM_with_OMI_day","P_LM_night","P_Lasso_day","P_lasso_night", "P_rf_day","P_rf_night","P_ctree_day")
 #for ( i in 1:10)
crossvali =  function(n,df, y_var) {
smp_size <- floor(0.8 * nrow(df)) 
set.seed(n)
training<- sample(seq_len(nrow(df)), size = smp_size)
test = seq_len(nrow(df))[-training] 

P_rf = rf_LUR(df, numtrees =  1000, mtry = 14, vis1 = F,y_varname= y_var, training=training, test=test, grepstring =varstring)
P_xgb= xgboost_LUR(df, max_depth =3, gamma=1, eta =0.05, nthread = 4, nrounds = 200, y_varname= y_var,training=training, test=test, grepstring =varstring)
P_Lasso =  Lasso(df,alpha =1 , vis1  = F,y_varname = y_var,training=training, test=test,grepstring =prestring )
 
V = cbind(P_rf, P_xgb, P_Lasso)
}
 
V2 = lapply(1:20, df = merged, y_var = y_var,crossvali)
V3 = data.frame(V2)
#save(V3, file = paste0("V3.rdata"))
```
 
```{r, eval=T}
#library(RColorBrewer)
nvaria = ncol(V2[[1]])
F1 = function(m, f=quote(summary)) {  apply(V3[, seq(m,ncol(V3), by =nvaria)], 1, f) }

plotresult = function(m0, DorN = c("mean of 20 times")){
m1 = melt(t(m0))
 

ggplot(m1, aes(Var2, value))+ geom_bar(stat = "identity",aes(fill = Var1),position = "dodge")+
  xlab("methods") + ylab("Accuracy") +
  ggtitle(paste0("bootstrap sub-sampling cross-validation: ", DorN)) +
  theme_bw()+theme(axis.text=element_text(size=15),legend.text=element_text(size=20),axis.title=element_text(size=15,face="bold"))+
    scale_fill_brewer(palette="Set2")  + theme(legend.title = element_blank()) 
}

library(stargazer)
meanvali = data.frame(sapply(1:nvaria, F1,  mean)) 
names( meanvali) = dimnames(V2[[1]])[[2]]
m0 = data.frame(t(meanvali))
row.names(m0) = c(  "XGB", "RF", "Lasso")
#m0$type1 = c(rep("day", 6), rep("night",5))
m0
stargazer(t(m0)) 
plotresult(m0) 
```
 

```{r, eval = F}
rfpred = rf_pre(NLDE_nonsp, numtrees = 1000, mtry = 24, y_varname= c("value_mean"), training=train_indsp, test=test_indsp, grepstring =varstring)
xgbpred = xgb_pre(NLDE_nonsp,max_depth =4, gamma=1, eta =0.1, nthread = 4, nrounds = 636, y_varname= c("value_mean"), training=train_indsp, test=test_indsp, grepstring =varstring)
 error_matrix(test_inde$value_mean,prediction = xgbpred)
error_matrix(test_inde$value_mean,prediction = rfpred) 
```
 
 plot
```{r}
xgbname = paste0(y_var,"xgb.tif")
rfname = paste0(y_var,"rfm.tif")
laname = paste0(y_var,"Lam.tif")


#use this to merge roads if needed: sr[[names(sr)[grepl("road_class",names(sr))]]]
sr3 = sr[[names(sr)[grepl("road_class_3_",names(sr))]]]
sr4 = sr[[names(sr)[grepl("road_class_4_",names(sr))]]]
sr5 = sr[[names(sr)[grepl("road_class_5_",names(sr))]]]
sr6 = sr[[names(sr)[grepl("road_class_1_|road_class_2_|temp|indu|wind|trop|Rsp|pop|OMI",names(sr))]]]
sr345 =sr3+sr4+sr5
names(sr345) = gsub("_1_","_M345_",names(sr3))
srmerged  = stack(sr345,sr6)


names(merged) =  gsub("M345", "3", names(merged)) # note 3 is for M345
# names(merged) =  gsub("population_1000", "pop1k", names(merged)) #  
# names(merged) =  gsub("population_3000", "pop3k", names(merged)) #  
# names(merged) =  gsub("population_5000", "pop5k", names(merged)) #  


predicLA_RF_XGBtiles(df = merged, rasstack = srmerged, yname = y_var, xgbname=xgbname, rfname = rfname, laname = laname, ntree = 1000, mtry = 14, gamma = 1,  max_depth = 3, eta = 0.05, nthread = 4, nrounds = 200 )



```


```{r prediction}
xgb = raster(xgbname)
 
rf = raster( rfname)
 
la = raster(laname)
 
 
s = stack(xgb, rf, la)
layerStats(s, "pearson")

 
#levelplot(s, at = my.at, par.settings = myTheme, names.attr = c("xgboost", "random forest", "lasso"))

```
 
bakfiets data, focus on morning because afternoon has too many missing data
```{r}
lf_lo = list.files("Bakfietsdata", pattern = "^.*morning.*.csv$", full.names = T)[-5]
```

clone raster
```{r}
xgbll = projectRaster(xgb, crs=   CRS("+init=epsg:4326"))
```

rasterize bakfiets data
```{r, eval  = F}
rasterize_bak = function(baklist, projras, aggfun)
    {
      bakfile1 = read.csv(baklist) %>% filter(NO2>2)
      coordinates(bakfile1) = ~Lon + Lat
      rasbf = rasterize(bakfile1,projras,"NO2", fun = aggfun) 
    }
  avebak =  lapply(lf_lo, rasterize_bak, xgbll, mean )%>%stack()
  #avebak %>%plot()
  avebf =avebak %>% calc(fun = mean)
```

rasterize temporally aggregated no2 bakfiets
```{r bakfiets}
library(lubridate)
xgbll = projectRaster(xgb, crs=   CRS("+init=epsg:4326"))
   # min is the number of minutes to aggregate no2 
rasterize_bak_min = function(baklist, projras, aggfun, agg_minu, hr)
    {
   
      bakfile1 = read.csv(baklist) %>% filter(NO2>2)
      time1=  as.POSIXlt(format(bakfile1$GPSTime, format = "%Y-%m-%d %H%M%S"))
      hour=  time1$hour 
      #bakfile1 = bakfile1%>% mutate(hours = hour)%>%group_by(hours)%>%mutate(hourlyNO2= mean(NO2, na.rm = T))
  
      lowtime <- min(time1)
      hightime <- max(time1)

# Set the minute and second to the nearest 10 minute value
      minute(lowtime) <- floor(minute(lowtime)/10) * 10
      minute(hightime) <- ceiling(minute(hightime)/10) * 10
      second(lowtime) <- 0
      second(hightime) <- 0

# Set the breakpoints at 10 minute intervals
     
      breakpoints <- seq.POSIXt(lowtime, hightime, by = agg_minu *60) # one minute 60, 600 : 10 minutes , 1200 20  
      bakfile1 = bakfile1%>%mutate(time=as.POSIXct(time1))%>%mutate(hours = hour)%>% filter( hour==hr)%>%mutate(aggretime =cut(time, breaks= breakpoints))%>%group_by(aggretime)%>%mutate(aggreNO2= mean(NO2, na.rm = T) )
      coordinates(bakfile1) = ~Lon + Lat
      rasbf = rasterize(bakfile1,projras,"aggreNO2", fun = aggfun) 
    }
  
```
 
Differences: bakfiets - modelprediction
```{r dif}

#'compare aggregated bakfiets and temporaly scaled global model prediction
#preras: global model
#bfras: bakfiets rasterized and averaged

compareras_dif= function(bfras, preras){ 
masked = mask(preras,bfras)
dif = bfras-masked
 
print(summary(dif)) 
print(ncell(dif))
dif
}

```

regression residuals (bakfiets ~ modelpredictions)
```{r}
compareras_res= function(bfras, preras){
 masked = mask(preras,bfras)
#dif = mxgb - bfras
 
 print(layerStats(stack(masked,bfras), "pearson", na.rm = T)[1] ) 
 
reg = lm(raster::getValues(bfras)~ raster::getValues(masked), na.action = na.exclude) 
print(summary(reg)$r.squared)
re = residuals(reg)
values(masked) = re
masked
}
```

## Calculate difference plot and residual plots, correlations
Calculate bakfiets averaged over 4 days, aggregate to every 15 minuts and 25 m resolution. 

```{r}
s = projectRaster(s, crs=   CRS("+init=epsg:4326"))

avebak = lapply(lf_lo,rasterize_bak_min, s[[1]], mean , agg_minu = 1, hr = whichhour)%>%stack()
 
avebf = avebak %>% calc(fun = mean)
 
```

```{r map8am}
myTheme2 <- rasterTheme(region = c(brewer.pal(9, "YlGnBu"), "black","black"), strip.background = list(col = 'transparent'), 
            strip.border = list(col = 'transparent'),  axis.line = list(col = "transparent") )
 my.at = seq(5, 60, by =5)
 p.strip <- list(cex=1 , lines=1, fontface='bold')
#levelplot(sr[["road_class_2_100"]],at = my.at, par.settings = myTheme2)
levelplot(stack(avebf, s),at = my.at, par.settings = myTheme2, names.attr = c("Cargo-bike", "XGBoost", "Random Forest", "Lasso"),par.strip.text =p.strip)

```


```{r difplot}
 
a = compareras_dif(avebf, s[[1]]) #xgb
 
a2 = compareras_dif(avebf, s[[2]]) #rf
 
a3 = compareras_dif(avebf,s[[3]]) #Lasso

my.at = seq(-30, 5, by =5) 
myTheme2 <- rasterTheme(region = c(brewer.pal(7, "Spectral")))
 
stack(a, a2, a3)%>%levelplot(at = my.at, par.settings = myTheme2, names.attr = c( "xgboost", "random forest", "lasso"))

```





comparison, different temporal aggregations
```{r resplot}
  #avebak %>%plot()

a = compareras_res(avebf, s[[1]]) #xgb
a2 = compareras_res(avebf, s[[2]]) #rf
a3 = compareras_res(avebf, s[[3]]) #Lasso
my.at = seq(-5, 5, by =1) 

stack(a,a2,a3)%>%levelplot(at = my.at, par.settings = myTheme2, names.attr = c( "xgboost", "random forest", "lasso"))
#ggsave("/Users/menglu/Documents/GitHub/nijmegen/nlde_vs_bak_res.png")
```

```{r}
fitvalue = function(preras, bikeras)
{
  masked = mask(preras,avebf)
  nonna <- Which(!is.na(masked), cells=TRUE)
  pre =  masked[nonna] 
  fitted( lm(bf~pre))
}
```


```{r 1d}

#'compare aggregated bakfiets and temporaly scaled global model prediction
#preras: global model
#bfras: bakfiets rasterized and averaged
 
nonna <- Which(!is.na(avebf), cells=TRUE)
bf = avebf[nonna] 
```

```{r 1d8am}
 
bikepre = data.frame(pixel_id = 1 : length(bf), Cargo_bike = bf,  fitted_XGB = fitvalue(s[[1]]), fitted_RF = fitvalue(s[[2]]), fitted_Lasso = fitvalue(s[[3]]))

df <- bikepre%>%  
  gather(key = "variable", value = "value", -pixel_id)
  
               
ggplot(df , aes(x=pixel_id, y =value)) + 
  geom_line(aes(color = variable, linetype = variable)) + 
    scale_color_brewer(name = paste0( "At ",whichhour, " a.m."), palette =  "Set2")+ 
  scale_linetype_discrete(paste0( "At ",whichhour, " a.m."))+theme_classic()+ theme(
  legend.title = element_text( size = 12),legend.text = element_text( size = 12), legend.position = c(0.9, 0.8))+
  labs(y = "NO2 concentration")
ggsave("modelfitted_bike1d.png", width = 12, height = 5)
 
```

